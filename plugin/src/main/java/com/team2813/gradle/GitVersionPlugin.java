/*
 * This source file was generated by the Gradle 'init' task
 */
package com.team2813.gradle;
import org.gradle.api.DefaultTask;
import org.gradle.api.GradleException;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.file.Directory;
import org.gradle.api.file.RegularFileProperty;
import org.gradle.api.plugins.JavaPlugin;
import org.gradle.api.plugins.JavaPluginExtension;
import org.gradle.api.provider.Property;
import org.gradle.api.provider.Provider;
import org.gradle.api.tasks.*;
import org.gradle.api.file.RegularFile;

import java.io.File;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

// TODO: Force load of java plugin before this plugin, or fail neatly if java plugin is not loaded (if possible)
public class GitVersionPlugin implements Plugin<Project> {
    private static final String EXTENSION_NAME = "git-details";
    private static final Path GEN_DIR = Path.of("generated","sources", EXTENSION_NAME);
    private static final String PROPERTY_PACKAGE = "properties";
    private static final String DEFAULT_PROPERTIES_FILE = "git-info.properties";
    private static final String RUST_MODULE_DIR = "native";
    private static final String RUST_BINARY_NAME = "git_details";

    private static final String BUILD_TASK_NAME = "buildPropertiesGenerator";
    private static final String BUILD_RUST_BINARY_TASK_NAME = "cargoBuildRelease";
    static final String GEN_PROPERTY_TASK_NAME = "createGitProperties";

    interface GitVersionExtension {
        Property<String> getGitPropertyPackage();
        Property<String> getPropertyFileName();
    }

    @Override
    public void apply(Project project) {
        // Ensure the cargo-wrapper plugin is applied first, as we rely on its generated task
        if (project.getPlugins().findPlugin("io.github.arc-blroth.cargo-wrapper") == null) {
            // Apply the cargo-wrapper plugin programmatically
            project.getPlugins().apply("io.github.arc-blroth.cargo-wrapper");
        }

        // 1. Allow configuration w/defaults
        var extension = project.getExtensions().create(EXTENSION_NAME, GitVersionExtension.class);
        extension.getGitPropertyPackage().convention(PROPERTY_PACKAGE);
        extension.getPropertyFileName().convention(DEFAULT_PROPERTIES_FILE);

        // 2. Locate the compiled HOST executable file
        // This path is stable and exists regardless of cross-compilation targets.
        // It points to: <ProjectRoot>/native/target/release/rust-generator
        RegularFile hostExecutableFile = project.getLayout().getProjectDirectory()
                .file(RUST_MODULE_DIR + "/target/release/" + RUST_BINARY_NAME);

        // 3. Register a task that executes the generated binary to generate the properties file.
        Provider<Directory> genDirProvider = project.getLayout().getBuildDirectory().dir(GEN_DIR.toString());
        var runTaskProvider = project.getTasks().register(GEN_PROPERTY_TASK_NAME, GeneratePropertyFileTask.class, runTask -> {
            // Set inputs for GeneratePropertyFileTask. First input is the rust binary.
            runTask.getRustExecutableFile().set(hostExecutableFile);

            // Second input is the output file.
            Provider<String> relativePathStringProvider = extension.getGitPropertyPackage()
                    .zip(extension.getPropertyFileName(), (gitPropertyPackage, propertyFileName) -> {
                        List<String> dirs = new ArrayList<>(Arrays.asList(gitPropertyPackage.split("\\.")));
                        String first = dirs.remove(0);
                        dirs.add(propertyFileName);

                        return Path.of(first, dirs.toArray(String[]::new)).toString();
                    });
            runTask.getOutputFile().set(genDirProvider.flatMap(genDir -> genDir.file(relativePathStringProvider)));

            runTask.setGroup("build");
            runTask.setDescription("Executes the Rust binary to generate a Java properties file.");
            runTask.dependsOn(BUILD_RUST_BINARY_TASK_NAME);
        });

        // The above task should be depended on by the java compilation task
        project.getTasks().getByName(JavaPlugin.PROCESS_RESOURCES_TASK_NAME).dependsOn(runTaskProvider);

        // add generated source set to the main source set.
        var sourceSets = project.getExtensions().getByType(JavaPluginExtension.class).getSourceSets();
        sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME).getResources().srcDir(genDirProvider);
    }

    static abstract class GeneratePropertyFileTask extends DefaultTask {
        public GeneratePropertyFileTask() {}

        @Input
        public abstract RegularFileProperty getRustExecutableFile();

        @Input
        abstract RegularFileProperty getOutputFile();

        @TaskAction
        public void createGitProperties() {
            Path repoPath = repoPath();
            File outputFile = getOutputFile().get().getAsFile();
            File executableFile = getRustExecutableFile().get().getAsFile();

            // Ensure the output file directory exists
            File outputDir = outputFile.getParentFile();
            if (!outputDir.exists()) {
                getLogger().lifecycle("Creating output directory: {}", outputDir);
                if (!outputDir.mkdirs()) {
                    throw new GradleException("Failed to create output directory: " + outputDir);
                }
            } else {
                getLogger().info("Found output directory: {}", outputDir);
            }

            getLogger().lifecycle("Executing Rust binary: " + executableFile.getAbsolutePath());
            getLogger().lifecycle("To generate properties file: " + outputFile.getAbsolutePath());

            try {
                getProject().exec(execSpec -> {
                    execSpec.commandLine(executableFile.getAbsolutePath(), repoPath.toString(), outputFile.getAbsolutePath());
                    execSpec.setIgnoreExitValue(false);
                });
                getLogger().lifecycle("Properties file successfully generated.");

            } catch (Exception e) {
                getLogger().error("Failed to execute Rust program: " + e.getMessage());
                throw new RuntimeException("Rust generator task failed.", e);
            }
        }

        private Path repoPath() {
            return getProject().getRootDir().toPath();
        }
    }
}
